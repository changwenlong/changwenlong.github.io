---
layout: post
title:  "JVM运行时数据区"
date:   2016-01-05
author: Changwl
categories: java jvm
excerpt: 低版本IE的bug和兼容性，点击空块级元素时
---

* content
{:toc}


## 介绍

JVM在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束来创建和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存划分如下图。

![runtime data area]({{"/static/imgs/jvm-runtime-data-area.png"}})

## 程序计数器

程序计数器 (Program Counter Register) 是一块很小内存空间。

由于 Java 是支持线程的语言，当线程数量超过 CPU 数量时，线程之间根据时间片轮询抢夺 CPU 资源。对于单核 CPU 而言，每一时刻只能有一个线程在运行，而其他线程必须被切换出去。

为此，每一个线程都必须用一个独立的程序计数器，用于记录下一条要运行的指令。各个线程之间的计数器互不影响，独立工作，是一块线程独有的内存空间。

如果当前线程正在执行一个 Java 方法，则程序计数器记录正在执行的 Java 字节码地址，如果当前线程正在执行一个 Native 方法，则程序计数器为空。

## Java虚拟机栈

虚拟机栈用于存放函数调用堆栈信息。

Java 虚拟机栈也是线程私有的内存空间，它和 Java 线程在同一时间创建，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

Java 虚拟机规范允许Java栈的大小是动态的或者是固定的。

在 Java 虚拟机规范中定义了两种异常与栈空间有关：`StackOverflowError` 和 `OutOfMemoryError`。

如果线程在计算过程中，请求的栈深度大于最大可用的栈深度，则抛出`StackOverflowError`；如果 Java 栈可以动态扩展，而在扩展栈的过程中没有足够的内存空间来支持栈的发展，则抛出 `OutOfMemeoryError`。可以使用`-Xss` 参数来设置栈的大小，栈的大小直接决定了函数调用的可达深度。

虚拟机栈在运行时使用一种叫做栈帧的数据结构保存上下文数据。在栈帧中，存放了方法的局部变量表、操作数栈、动态连接方法和返回地址等信息。每一个方法的调用都伴随着栈帧的入栈操作。相应地，方法的返回则表示栈帧的出栈操作。如果方法调用时，方法的参数和局部变量相对较多，那么栈帧中的局部变量表就会比较大，栈帧会膨胀以满足方法调用所需传递的信息。因此，单个方法调用所需的栈空间大小也会比较多。

函数嵌套调用的次数由栈的大小决定。栈越大，函数嵌套调用次数越多。对一个函数而言，它的参数越多，内部局部变量越多，它的栈帧就越大，其嵌套调用次数就会减少。

## 本地方法栈

本地方法栈和 Java 虚拟机栈的功能很相似，本地方法栈用于存放函数调用堆栈信息。

Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈用于管理本地方法的调用。本地方法并不是用 Java 实现的，而是使用 C 实现的。在 SUN 的 HotSpot 虚拟机中，不区分本地方法栈和虚拟机栈。因此，和虚拟机栈一样，它也会抛出 `StackOverflowError` 和 `OutofMemoryError`。

## Java堆

堆用于存放 Java 程序运行时所需的对象等数据。

几乎所有的对象和数组都是在堆中分配空间的。

Java 堆分为新生代和老生代两个部分，新生代用于存放刚刚产生的对象和年轻的对象，如果对象一直没有被回收，生存得足够长，老年对象就被移入老年代。

新生代又可进一步细分为 eden、survivor space0 和 survivor space1。

eden 即对象的出生地，大部分对象刚刚建立时都会被存放在这里。

survivor 空间是存放其中的对象至少经历了一次垃圾回收，并得以幸存下来的。如果在幸存区的对象到了指定年龄仍未被回收，则有机会进入老年代 (tenured)。下面例子演示了对象在内存中的分配方式。

JVM的垃圾回收主要就是作用于Java堆。

## 方法区

方法区用于存放程序的类元数据信息。

方法区与堆空间类似，它也是被 JVM 中所有的线程共享的。

方法区主要保存的信息是类的元数据。方法区中最为重要的是类的类型信息、常量池、域信息、方法信息。类型信息包括类的完整名称、父类的完整名称、类型修饰符和类型的直接接口类表；

常量池包括这个类方法、域等信息所引用的常量信息；域信息包括域名称、域类型和域修饰符；方法信息包括方法名称、返回类型、方法参数、方法修饰符、方法字节码、操作数栈和方法栈帧的局部变量区大小以及异常表。总之，方法区内保持的信息大部分来自于 class 文件，是 Java 应用程序运行必不可少的重要数据。

在 Hot Spot 虚拟机中，方法区也称为永久区，是一块独立于 Java 堆的内存空间。虽然叫做永久区，但是在永久区中的对象同样也可以被 GC 回收的。只是对于 GC 的表现也和 Java 堆空间略有不同。对永久区 GC 的回收，通常主要从两个方面分析：一是 GC 对永久区常量池的回收；二是永久区对类元数据的回收。HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。

### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出`OutOfMemoryError`异常。

> 关于字面量

    //此处的1被称为字面量，Integer引用的字面量在-128~127之间时，不会new新的Integer对象，而是直接去常量池取
    Integer a = 1;
    Integer b = 1;
    System.out.println(a==b);
    
    //String引用指向的abc为字面量，存放在常量池中
    String str1 = "abc";
    String str2 = "abc";
    System.out.println(str1==str2);
    //new方法在java堆上创建了字符串，intern方法会将字符串拷贝至常量池并返回
    String str3 = new String("abc").intern();
    System.out.println(str1==str3);

    //输出为 true true true

## 直接内存

Direct Memory并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分也是频繁使用。在Java的NIO中使用到，服务器管理员忽略直接内存后果是，各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。

## 总结

在使用某些区域时，有时会遇到`OutOfMemoryError`与`StackOverflowError`这样的error。


> 如：java虚拟机栈、本地方法栈内存不足时，抛出`StackOverflowError`；
> 
> java堆、方法区内存不足时，则抛出`OutOfMemoryError`。

[通过示例学习StackOverflowError和OutOfMemoryError](/2016/01/10/StackOverflowError-OutOfMemoryError "StackOverflowError & OutOfMemoryError") 将通过具体示例展现这些Error。


## 参考

[深入理解Java虚拟机（第2版）](http://book.douban.com/subject/24722612/ "深入理解Java虚拟机（第2版）")

[JVM 数据存储介绍及性能优化](http://www.ibm.com/developerworks/cn/java/j-lo-JVM-Optimize/index.html "JVM 数据存储介绍及性能优化")


