---
layout: post
title:  "HashMap工作原理"
date:   2015-12-20
author: Changwl
categories: java
excerpt: 低版本IE的bug和兼容性，点击空块级元素时
---

* content
{:toc}

##介绍

HashMap底层使用hash表实现，解决冲突的方法是链地址法，简单理解起来就是采用数组加链表得数据结构来存储数据。

下面开始分析HashMap的源代码，从数据的增删该查等方面进行分析。

##创建HashMap

1.构造函数

设置HashMap的初始化大小initialCapacity和平衡因子loadFactor;

无参构造函数使用默认的初始化大小16，平衡因子0.75；

当entry数大于capacity*loadFactor时，会进行resize，reside会导致key进行rehash。

   
	 public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal initial capacity: " +
                                               initialCapacity);
        if (initialCapacity > MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException("Illegal load factor: " +
                                               loadFactor);

        this.loadFactor = loadFactor;
        threshold = initialCapacity;
        init();
    }

  
    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR);
    }

   
    public HashMap() {
        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
    }


##新增与修改

HashMap的新增与修改操作，通过`put`方法实现。

1.`put`方法源码
		   
	public V put(K key, V value) {
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        if (key == null)
            return putForNullKey(value);
        int hash = hash(key);
        int i = indexFor(hash, table.length);
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        addEntry(hash, key, value, i);
        return null;
    }
    
2.分析

使用put方法为HashMap新增键值对。

table为一个Entry<K,V>数组，Entry<k,v>为一个链表元素，也就是说table数组中存储的是链表，也成为bucket（桶）；


键的hash值相同的Entry存储在同一个bucket（桶）中；

源码采用函数`indexFor`来索引数组的位置，`hash(key)`和`table.length-1`作与运算，这样可确保所得结果处于0~`table.length`

 	static int indexFor(int h, int length) {
        // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
        return h & (length-1);
    }

索引到数组的位置后，接着就是将元素存入相应的桶中，遍历桶中元素，将键值与入参键（key）比较，若相同，则替换掉键对应的值（value），此处不仅要比较hash值，还要`equals`比较。若桶中无相同键，调用`addEntry`新增元素。

`addEntry`并不是简单的往桶中添加的元素，如上文中提到，当entry数大于capacity*loadFactor时，会进行resize，reside会导致key进行rehash。

    void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size >= threshold) && (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }

##删除

1.`remove`方法源码

    public V remove(Object key) {
        Entry<K,V> e = removeEntryForKey(key);
        return (e == null ? null : e.value);
    }

    final Entry<K,V> removeEntryForKey(Object key) {
        if (size == 0) {
            return null;
        }
        int hash = (key == null) ? 0 : hash(key);
        int i = indexFor(hash, table.length);
        Entry<K,V> prev = table[i];
        Entry<K,V> e = prev;

        while (e != null) {
            Entry<K,V> next = e.next;
            Object k;
            if (e.hash == hash &&
                ((k = e.key) == key || (key != null && key.equals(k)))) {
                modCount++;
                size--;
                if (prev == e)
                    table[i] = next;
                else
                    prev.next = next;
                e.recordRemoval(this);
                return e;
            }
            prev = e;
            e = next;
        }

        return e;
    }

2.分析

remove方法与put方法原理大致相同。

通过key索引数组位置，遍历相应位置的桶，找到相同元素，执行链表删除。

##查找

1.`get`方法源码
 
	public V get(Object key) {
        if (key == null)
            return getForNullKey();
        Entry<K,V> entry = getEntry(key);

        return null == entry ? null : entry.getValue();
    }

    final Entry<K,V> getEntry(Object key) {
        if (size == 0) {
            return null;
        }

        int hash = (key == null) ? 0 : hash(key);
        for (Entry<K,V> e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &&
                ((k = e.key) == key || (key != null && key.equals(k))))
                return e;
        }
        return null;
    }

2.分析

`get`方法调用`getEntry`,`getEntry`的实现与`put`和`removeEntryForKey`类似。

##`Null`键

HashMap允许使用`Null`作为键，相应的增删该查方法也有对`Null`键的特殊处理；

分析代码我们不难看出，`Null`键索引的是`table[0]`
	
	private V putForNullKey(V value) {
        for (Entry<K,V> e = table[0]; e != null; e = e.next) {
            if (e.key == null) {
                V oldValue = e.value;
                e.value = value;
                e.recordAccess(this);
                return oldValue;
            }
        }
        modCount++;
        addEntry(0, null, value, 0);
        return null;
    }

	private V getForNullKey() {
        if (size == 0) {
            return null;
        }
        for (Entry<K,V> e = table[0]; e != null; e = e.next) {
            if (e.key == null)
                return e.value;
        }
        return null;
    }

`removeEntryForKey`也对`Null`键做了处理

	int hash = (key == null) ? 0 : hash(key);
    int i = indexFor(hash, table.length);

##实现Cloneable接口

重写Object类中的`clone`方法，实现了浅拷贝。

1.`clone`方法源码

    /**
     * Returns a shallow copy of this <tt>HashMap</tt> instance: the keys and
     * values themselves are not cloned.
     *
     * @return a shallow copy of this map
     */
    public Object clone() {
        HashMap<K,V> result = null;
        try {
            result = (HashMap<K,V>)super.clone();
        } catch (CloneNotSupportedException e) {
            // assert false;
        }
        if (result.table != EMPTY_TABLE) {
            result.inflateTable(Math.min(
                (int) Math.min(
                    size * Math.min(1 / loadFactor, 4.0f),
                    // we have limits...
                    HashMap.MAXIMUM_CAPACITY),
               table.length));
        }
        result.entrySet = null;
        result.modCount = 0;
        result.size = 0;
        result.init();
        result.putAllForCreate(this);

        return result;
    }

    private void putAllForCreate(Map<? extends K, ? extends V> m) {
        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
            putForCreate(e.getKey(), e.getValue());
    }

    private void putForCreate(K key, V value) {
        int hash = null == key ? 0 : hash(key);
        int i = indexFor(hash, table.length);

        /**
         * Look for preexisting entry for key.  This will never happen for
         * clone or deserialize.  It will only happen for construction if the
         * input Map is a sorted map whose ordering is inconsistent w/ equals.
         */
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash &&
                ((k = e.key) == key || (key != null && key.equals(k)))) {
                e.value = value;
                return;
            }
        }

        createEntry(hash, key, value, i);
    }

2.示例证明浅拷贝

	package edu.zju.chwl.map;
	
	import java.util.HashMap;
	import org.junit.Test;
	
	public class TestHashMap {

		@Test
		public void test() {
			HashMap<String, Student> hashMap = new HashMap<String, Student>();
			Student stu = new Student("tom", 26);
			hashMap.put("tom", stu);
			HashMap<String, String> cloneHashMap = (HashMap<String, String>) hashMap.clone();
			stu.setName("tony");
			System.out.println("hashMap:" + hashMap);
			System.out.println("cloneHashMap:" + cloneHashMap);
		}
	
		class Student {
			private String name;
			private int age;
	
			Student(String name, int age) {
				this.name = name;
				this.age = age;
			}
	
			public void setName(String name) {
				this.name = name;
			}
	
			@Override
			public String toString() {
				return "name:" + name + ",age:" + age;
			}
	
		}
	}

打印结果：

> hashMap:{tom=name:tony,age:26}
> 
>cloneHashMap:{tom=name:tony,age:26}

证明clone方法并未对键，值进行深拷贝。

##实现Serializable接口

自定义序列化，实现`readObject`方法与`writeObject`方法

...待续

##参考
[Java HashMap 源码解析](http://liujiacai.net/blog/2015/09/03/java-hashmap "Java HashMap 源码解析")